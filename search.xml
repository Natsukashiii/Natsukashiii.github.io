<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F21%2FHello-World-0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSONObject/JSONArray]]></title>
    <url>%2F2018%2F05%2F06%2FJSONObject%3AJSONArray%2F</url>
    <content type="text"><![CDATA[TEST-JSONObject和JSONArray JSON可以有两种格式，一种是对象格式的，另一种是数组对象， 1&#123;"name":"JSON","address":"北京市西城区","age":25&#125;//JSON的对象格式的字符串 1[&#123;"name":"JSON","address":"北京市西城区","age":25&#125;]//数据对象格式 从上面的两种格式可以看出对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。 在前端和后端进行数据传输的时候这种格式也是很受欢迎的，后端返回json格式的字符串，前台使用js中的JSON.parse()方法把JSON字符串解析为json对象，然后进行遍历，供前端使用。 下面进入正题，介绍在JAVA中JSON和java对象之间的互转。 要想实现JSON和java对象之间的互转，需要借助第三方jar包，这里使用json-lib这个jar包，下载地址为：https://sourceforge.net/projects/json-lib/，json-lib需要commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、ezmorph-1.0.6.jar五个包的支持，可以自行从网上下载，这里不再贴出下载地址。 json-lib提供了几个类可以完成此功能，例，JSONObject、JSONArray。从类的名字上可以看出JSONObject转化的应该是对象格式的，而JSONArray转化的则应该是数组对象（即，带[]形式）的。 一、java普通对象和json字符串的互转 java对象–》》字符串 java普通对象指的是java中的一个java bean，即一个实体类，如， 1234567891011121314151617181920212223242526272829303132333435package com.cn.study.day3;public class Student &#123; //姓名 private String name; //年龄 private String age; //住址 private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + ", address=" + address + "]"; &#125; &#125;上面是我的一个普通的java实体类，看json-lib如何把它转化为字符串形式， 123456789101112131415161718public static void convertObject() &#123; Student stu=new Student(); stu.setName("JSON"); stu.setAge("23"); stu.setAddress("北京市西城区"); //1、使用JSONObject JSONObject json = JSONObject.fromObject(stu); //2、使用JSONArray JSONArray array=JSONArray.fromObject(stu); String strJson=json.toString(); String strArray=array.toString(); System.out.println("strJson:"+strJson); System.out.println("strArray:"+strArray); &#125;我定义了一个Student的实体类，然后分别使用了JSONObject和JSONArray两种方式转化为JSON字符串，下面看打印的结果， 12strJson:&#123;"address":"北京市西城区","age":"23","name":"JSON"&#125;strArray:[&#123;"address":"北京市西城区","age":"23","name":"JSON"&#125;] 从结果中可以看出两种方法都可以把java对象转化为JSON字符串，只是转化后的结构不同。 JSON字符串–》》java对象 上面说明了如何把java对象转化为JSON字符串，下面看如何把JSON字符串格式转化为java对象， 首先需要定义两种不同格式的字符串，需要使用\对双引号进行转义， 12345678910111213141516171819public static void jsonStrToJava()&#123; //定义两种不同格式的字符串 String objectStr="&#123;\"name\":\"JSON\",\"age\":\"24\",\"address\":\"北京市西城区\"&#125;"; String arrayStr="[&#123;\"name\":\"JSON\",\"age\":\"24\",\"address\":\"北京市西城区\"&#125;]"; //1、使用JSONObject JSONObject jsonObject=JSONObject.fromObject(objectStr); Student stu=(Student)JSONObject.toBean(jsonObject, Student.class); //2、使用JSONArray JSONArray jsonArray=JSONArray.fromObject(arrayStr); //获得jsonArray的第一个元素 Object o=jsonArray.get(0); JSONObject jsonObject2=JSONObject.fromObject(o); Student stu2=(Student)JSONObject.toBean(jsonObject2, Student.class); System.out.println("stu:"+stu); System.out.println("stu2:"+stu2); &#125; 打印结果为： 12stu:Student [name=JSON, age=24, address=北京市西城区]stu2:Student [name=JSON, age=24, address=北京市西城区] 从上面的代码中可以看出，使用JSONObject可以轻松的把JSON格式的字符串转化为java对象，但是使用JSONArray就没那么容易了，因为它有“[]”符号，所以我们这里在获得了JSONArray的对象之后，取其第一个元素即我们需要的一个student的变形，然后使用JSONObject轻松获得。 二、list和json字符串的互转 list–》》json字符串 ;) 12345678910111213141516public static void listToJSON()&#123; Student stu=new Student(); stu.setName("JSON"); stu.setAge("23"); stu.setAddress("北京市海淀区"); List&lt;Student&gt; lists=new ArrayList&lt;Student&gt;(); lists.add(stu); //1、使用JSONObject //JSONObject listObject=JSONObject.fromObject(lists); //2、使用JSONArray JSONArray listArray=JSONArray.fromObject(lists); //System.out.println("listObject:"+listObject.toString()); System.out.println("listArray:"+listArray.toString()); &#125; 我把使用JSONObject的方式给注掉了，我们先看注释之前的结果， 1Exception in thread "main" net.sf.json.JSONException: 'object' is an array. Use JSONArray instead 告诉我说有一个异常，通过查看源码发现，在使用fromObject方法的时候会先进行参数类型的判断，这里就告诉我们，传入的参数是一个array类型，因为使用的ArrayList，再来看，注释之后的结果， 1listArray:[&#123;"address":"北京市海淀区","age":"23","name":"JSON"&#125;] 这样结果是正常的。 json字符串–》》list 从上面的例子可以看出list的对象只能转化为数组对象的格式，那么我们看下面的字符串到list的转化， 12345678910111213141516public static void jsonToList()&#123; String arrayStr="[&#123;\"name\":\"JSON\",\"age\":\"24\",\"address\":\"北京市西城区\"&#125;]"; //转化为list List&lt;Student&gt; list2=(List&lt;Student&gt;)JSONArray.toList(JSONArray.fromObject(arrayStr), Student.class); for (Student stu : list2) &#123; System.out.println(stu); &#125; //转化为数组 Student[] ss =(Student[])JSONArray.toArray(JSONArray.fromObject(arrayStr),Student.class); for (Student student : ss) &#123; System.out.println(student); &#125; &#125; 打印结果， 12Student [name=JSON, age=24, address=北京市西城区]Student [name=JSON, age=24, address=北京市西城区] 由于字符串的格式为带有“[]”的格式，所以这里选择JSONArray这个对象，它有toArray、toList方法可供使用，前者转化为java中的数组，或者转化为java中的list，由于这里有实体类进行对应，所以在使用时指定了泛型的类型（Student.class），这样就可以得到转化后的对象。 三、map和json字符串的互转 map–》》json字符串 12345678910111213141516public static void mapToJSON()&#123; Student stu=new Student(); stu.setName("JSON"); stu.setAge("23"); stu.setAddress("中国上海"); Map&lt;String,Student&gt; map=new HashMap&lt;String,Student&gt;(); map.put("first", stu); //1、JSONObject JSONObject mapObject=JSONObject.fromObject(map); System.out.println("mapObject"+mapObject.toString()); //2、JSONArray JSONArray mapArray=JSONArray.fromObject(map); System.out.println("mapArray:"+mapArray.toString()); &#125; 打印结果， 12mapObject&#123;"first":&#123;"address":"中国上海","age":"23","name":"JSON"&#125;&#125;mapArray:[&#123;"first":&#123;"address":"中国上海","age":"23","name":"JSON"&#125;&#125;] 上面打印了两种形式。 json字符串–》》map JSON字符串不能直接转化为map对象，要想取得map中的键对应的值需要别的方式， 12345678910111213public static void jsonToMap()&#123; String strObject="&#123;\"first\":&#123;\"address\":\"中国上海\",\"age\":\"23\",\"name\":\"JSON\"&#125;&#125;"; //JSONObject JSONObject jsonObject=JSONObject.fromObject(strObject); Map map=new HashMap(); map.put("first", Student.class); //使用了toBean方法，需要三个参数 MyBean my=(MyBean)JSONObject.toBean(jsonObject, MyBean.class, map); System.out.println(my.getFirst()); &#125; 打印结果， 1Student [name=JSON, age=23, address=中国上海] 下面是MyBean的代码， 123456789101112131415161718192021package com.cn.study.day4;import java.util.Map;import com.cn.study.day3.Student;public class MyBean &#123; private Student first; public Student getFirst() &#123; return first; &#125; public void setFirst(Student first) &#123; this.first = first; &#125; &#125; 使用toBean()方法是传入了三个参数，第一个是JSONObject对象，第二个是MyBean.class，第三个是一个Map对象。通过MyBean可以知道此类中要有一个first的属性，且其类型为Student，要和map中的键和值类型对应，即，first对应键 first类型对应值的类型。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译/修改/重新打包/签名]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%8F%8D%E7%BC%96%E8%AF%91APK%2F</url>
    <content type="text"><![CDATA[反编译/修改/重新打包/签名 工具：apktool/dex2jar/JD-GUI apktool 安装apktool的时候，按官网的操作不能直接存成apktool，会自动带.sh后缀，但是这个格式复制到/usr/local/bin之后 apktool command not find，最后尝试了一下直接在bin里改名字之后apktool就有提示了 在有apk的文件夹下，apktool d xx.apk 就生成反编译之后的文件 apktool b xxx，会生成build和dist文件夹，回编译出来的apk在dist目录下，但是build/apk文件夹里会少了original文件夹下的META-INF文件夹 dex2jar 有毒。。教程是要把classes.dex文件放到d2j的文件夹下，但是一直找不到命令 最后把原来的apk放进去才有反应。。。 chmod +x d2j-dex2jar.sh/d2j_invoke.sh添加权限 执行 d2j_dex2jar.sh xx.apk 生成的xx-dex2jar文件就在dex2jar的文件夹里 JD-GUI jar文件JDGUI直接拖进去看就行了 修改 AndroidManefist.xml文件里有MainActivity的入口，在JDGUL里查看之后但是还没看懂。。其他改smail代码但是也不会。。只能改字段了。。。 如果只是修改一个界面的话，apk首页的文字应该在values里会有一个string类，所以直接在apktool反编译之后的文件夹下的，/res/values/里的文件找，下面文件夹比较多，根目录下arrays.xml里面就有首页的文字段.. 重新打包 直接在之前apktool反编译的目录下，apktool b xxx回编译，会生成build和dist文件夹，dist文件夹里就是生成的apk文件 也可以 apktool.bat b -o &lt;output.apk&gt; &lt;input_dir&gt; 指定输出目录和apk文件名 签名 dist下的apk文件不能直接安装，会显示没有签名… 先需要keystore文件 keytool -genkey -alias xx.keystore -keyalg RSA -validity 40000 -keystore xx.keystore -genkey 产生证书； -alias 产生别名； -keystore：指定密钥库的.keystore文件中；-keyalg：密钥算法，这里是RSA；-validity：证书有效天数 产生的提示里的keystore密码就是后面签名APK要输入的 签名apk jarsigner -verbose -keystore xx.keystore xx.apk xx.keystore -verbose：指定生成输出；-keystore：指定证书的存储路径 之后apk就能安装，但是如果之前已经装过这个apk需要先卸载，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>apktool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sharedpreferences]]></title>
    <url>%2F2018%2F04%2F28%2FSharedPreferences%2F</url>
    <content type="text"><![CDATA[Sharedpreferences 轻量级的存储类，KEY/VALUE形式，类似键值对 其中的原理是通过Android系统生成一个xml文件保到：/data/data/包名/shared_prefs目录下//DDMS里data文件夹权限是drwxrsw–x，需要修改权限才能打开 支持Java基本数据类型保存接口比如：int、long、boolean、String、Float、Set和Map这些数据类型。 实现方法： 先获取一个SharedPreferences对象:1.第一个参数是生成的存储文件的名字，第二个参数是存储的格式：SharedPreferenced sp=Context.getSharedPreferences(&quot;sp_demo&quot;,Context.MODE_PRIVATE); MODE_PRIVATE：默认操作模式，只有当前的应用程序才可以对整个SharedPreferences文件读写； MODE_MULTI_PRIVATE：多个进程共同操作同一个文件 获取edit对象：Editor editor = sp.edit(); 通过editor对象写入，也可以putInt、putBoolean：edit.putString(&quot;name&quot;,&quot;John&quot;); 直接用edit的方式没法存储，因为sp.edit()每次都会返回一个新的Editor对象，Editor的实现类EditorImpl里面会有一个缓存的Map，最后commit的时候先将缓存里面的Map写入内存中的Map，然后将内存中的Map写进XML文件中。使用上面的方式commit，由于sp.edit()又重新返回了一个新的Editor对象，缓存中的Map是空的，所以没法存储 提交数据到xml文件中：edit.commit(); 取出数据 第一个参数是写入的键，第二个参数是如果没有获取到数据就默认返回的值：String name = sp.getString(&quot;name&quot;,null); 如果类没有继承Activity，不能直接用getSharedPreferences方法context.getSharedPreferences(); 实现代码： SharedPreferences pref =MainActivity.this.getSharedPreferences(“data”,MODE_PRIVATE);SharedPreferences.Editor editor = pref.edit();editor.putString(“name”,”lily”);editor.putString(“age”,”20”);editor.putBoolean(“married”,false);editor.commit();-]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>sharedpreferences</tag>
      </tags>
  </entry>
</search>
